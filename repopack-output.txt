================================================================
Repopack Output File
================================================================

This file was generated by Repopack on: 2024-08-27T19:34:12.879Z

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This header section
2. Repository structure
3. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
1. This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
2. When processing this file, use the separators and "File:" markers to
  distinguish between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.



For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
neopixelcontroller/neopixelcontroller.cpp
neopixelcontroller/neopixelcontroller.h
README.md
smartstrip.cpp
smartstrip.h
webserver/routehandler/routehandler.cpp
webserver/routehandler/routehandler.h
webserver/webserver.cpp
webserver/webserver.h

================================================================
Repository Files
================================================================

================
File: neopixelcontroller/neopixelcontroller.cpp
================
#include "neopixelcontroller.h"

NeopixelController::NeopixelController(int _pin, int _pixels) : 
                                           pin(_pin),
                                           pixels(_pixels),
                                           status(WHITE),
                                           brightness(0),
                                           rgbfade_speed(10),
                                           strip(_pixels, _pin, NEO_GRBW + NEO_KHZ800)
{ }

void NeopixelController::init() {
    pinMode(pin, OUTPUT);
    this->setup_strip(&this->strip);
}

void NeopixelController::setup_strip(Adafruit_NeoPixel* strip) {
  strip->begin();
  strip->show();
  strip->setBrightness(BRIGHTNESS);
}

void NeopixelController::tick() {
    // Smoothly interpolate between the previous color and new color
    if(h != target_h || s != target_s || v != target_v) {
        int16_t h_diff = (int16_t)target_h - (int16_t)h;
    
        // Adjust h_diff to always represent the shortest path
        if (h_diff > 32767) h_diff -= 65536;
        else if (h_diff < -32768) h_diff += 65536;
        
        uint16_t abs_h_diff = abs(h_diff);
        uint16_t h_speed = max((uint16_t)ceil(abs_h_diff / 20), (uint16_t)1);


        if (abs_h_diff <= 32768) {
            // Move in the direction of h_diff
            if (abs_h_diff <= h_speed) {
                h = target_h;
            } else {
                h = (uint16_t)((int32_t)h + (h_diff > 0 ? h_speed : -h_speed));
            }
        } else {
            // Move in the opposite direction (shorter path)
            if (65536 - abs_h_diff <= h_speed) {
                h = target_h;
            } else {
                h = (uint16_t)((int32_t)h + (h_diff > 0 ? -h_speed : h_speed));
            }
        }

        if(target_s > s) {
            if(s + SPEED > target_s || s + SPEED < s) s = target_s;
            else s += SPEED;
        } else {
            if(s - SPEED < target_s || s - SPEED > s) s = target_s;
            else s -= SPEED;
        }

        if(target_v > v) {
            if(v + SPEED > target_v || v + SPEED < v) v = target_v;
            else v += SPEED;
        } else {
            if(v - SPEED < target_v || v - SPEED > v) v = target_v;
            else v -= SPEED;
        }
    }
    
    if(brightness != target_brightness) {
        if(target_brightness > brightness) {
            brightness += SPEED;
        } else {
            brightness -= SPEED;
        }

        brightness = constrain(brightness, 0, 255);
    }

    switch (status) {
        case WHITE:
            this->white(&this->strip);
            break;
        case COLOR:
            this->color(&this->strip);
            break;
        case RGB_FADE:
            this->rgb_fade();
            this->color(&this->strip);
            break;
    }
    
    strip.show();
}

void NeopixelController::white(Adafruit_NeoPixel* strip) {
    strip->setBrightness(brightness);
    strip->fill(strip->Color(0, 0, 0, strip->gamma8(brightness)));
}

void NeopixelController::turn_on() {
    this->target_brightness = 255;
    this->white(&this->strip);
}

void NeopixelController::turn_off() {
    this->target_brightness = 0;
    this->white(&this->strip);
}

void NeopixelController::set_color(uint16_t hue, uint8_t sat, uint8_t val) {
    this->target_h = hue;
    this->target_s = sat;
    this->target_v = val;
    this->status = COLOR;
}

void NeopixelController::color(Adafruit_NeoPixel* strip) {
    strip->setBrightness(brightness);

    for (int i = 0; i < strip->numPixels(); i++) {
        strip->setPixelColor(i, strip->ColorHSV(h, s, v));
    }
}

LedStatus NeopixelController::get_status() {
    return status;
}

void NeopixelController::set_brightness(int brightness) {
    this->target_brightness = brightness;
}

void NeopixelController::set_mode(LedStatus status) {
    this->status = status;
}

void NeopixelController::set_fade_speed(int speed) {
    this->rgbfade_speed = speed;
}

void NeopixelController::rgb_fade() {
    target_h += rgbfade_speed;
    target_s = 255;
    target_v = 255;
}

================
File: neopixelcontroller/neopixelcontroller.h
================
#ifndef NEOPIXEL_CONTROLLER_H
#define NEOPIXEL_CONTROLLER_H

#include <Adafruit_NeoPixel.h>
#include <Arduino.h>

#define BRIGHTNESS 50

#define PURPLE 56000
#define BLUE 40000

#define SPEED 2

enum LedStatus {
    WHITE,
    COLOR,
    RGB_FADE
};

class NeopixelController {
public:
    NeopixelController(int pin, int pixels);
    void init();
    void setup_strip(Adafruit_NeoPixel*);
    void tick();
    void white(Adafruit_NeoPixel*);
    void turn_on();
    void turn_off();
    void set_brightness(int);
    void set_color(uint16_t hue, uint8_t sat, uint8_t val);
    void color(Adafruit_NeoPixel*);
    void set_mode(LedStatus);
    void rgb_fade();
    void set_fade_speed(int);
    LedStatus get_status();
private:
    Adafruit_NeoPixel strip;
    LedStatus status;
    int pin;
    int pixels;
    int brightness;
    uint16_t h;
    uint8_t s;
    uint8_t v;
    uint16_t target_h;
    uint8_t target_s;
    uint8_t target_v;
    int target_brightness;
    int rgbfade_speed;
};

#endif

================
File: README.md
================
_

================
File: smartstrip.cpp
================
#include "smartstrip.h"

SmartStrip::SmartStrip(String mdnsName, int neopixelPin, int ledCount): 
webServer(mdnsName), 
neopixelController(neopixelPin, ledCount) 
{ }

void SmartStrip::init() {
    webServer.init();
    neopixelController.init();

    // Register API Routes using lambda functions to capture 'this'
    webServer.registerRoute(new RouteHandler(HTTPMethod::POST, "/power/on", [this](String url, WiFiClient& client) {
        this->powerOn(url, client);
    }));
    webServer.registerRoute(new RouteHandler(HTTPMethod::POST, "/power/off", [this](String url, WiFiClient& client) {
        this->powerOff(url, client);
    }));
    webServer.registerRoute(new RouteHandler(HTTPMethod::POST, "/color/hsv", [this](String url, WiFiClient& client) {
        this->colorHsv(url, client);
    }));
    webServer.registerRoute(new RouteHandler(HTTPMethod::POST, "/brightness", [this](String url, WiFiClient& client) {
        this->setBrightness(url, client);
    }));
    webServer.registerRoute(new RouteHandler(HTTPMethod::POST, "/mode", [this](String url, WiFiClient& client) {
        this->setMode(url, client);
    }));
    webServer.registerRoute(new RouteHandler(HTTPMethod::POST, "/fade-speed", [this](String url, WiFiClient& client) {
        this->setFadeSpeed(url, client);
    }));
}


void SmartStrip::tick() {
    webServer.tick();
    neopixelController.tick();
}


void SmartStrip::powerOff(String url, WiFiClient& client) {
    Serial.println("Powering off shelf.");
    neopixelController.turn_off();
}

void SmartStrip::powerOn(String url, WiFiClient& client) {
    Serial.println("Powering on shelf.");
    neopixelController.turn_on();
}

void SmartStrip::colorHsv(String url, WiFiClient& client) {
    Serial.println("Setting shelf color.");
    Serial.println(url);

    uint16_t h;
    uint8_t s;
    uint8_t v;

    h = url.substring(url.indexOf("h=") + 2, url.indexOf("&s=")).toInt();
    s = url.substring(url.indexOf("s=") + 2, url.indexOf("&v=")).toInt();
    v = url.substring(url.indexOf("v=") + 2).toInt();

    neopixelController.set_color(h, s, v);
}

void SmartStrip::setBrightness(String url, WiFiClient& client) {
    Serial.println("Setting brightness.");
    Serial.println(url);

    int brightness = url.substring(url.indexOf("brightness=") + 11).toInt();
    neopixelController.set_brightness(brightness);
}

void SmartStrip::setMode(String url, WiFiClient& client) {
    if(url.indexOf("/white") >= 0) {
        Serial.println("Setting shelf mode to white.");
        neopixelController.set_mode(LedStatus::WHITE);
    } else if(url.indexOf("/color") >= 0) {
        Serial.println("Setting shelf mode to color.");
        neopixelController.set_mode(LedStatus::COLOR);
    } else if(url.indexOf("/rgb-fade") >= 0) {
        Serial.println("Setting mode to rgb fade.");
        neopixelController.set_mode(LedStatus::RGB_FADE);
    }
}

void SmartStrip::setFadeSpeed(String url, WiFiClient& client) {
    Serial.println("Setting fade speed.");
    Serial.println(url);

    int speed;

    sscanf(url.c_str(), "POST /fade-speed?speed=%d", &speed);

    neopixelController.set_fade_speed(speed);
}

================
File: smartstrip.h
================
#ifndef SMARTSTRIP_H
#define SMARTSTRIP_H

#include "./neopixelcontroller/neopixelcontroller.h"
#include "./webserver/webserver.h"
#include "Arduino.h"

class SmartStrip {
public:
    SmartStrip(String mdnsName, int neopixelPin, int ledCount);
    void init();
    void tick();
private:
    WebServer webServer;
    NeopixelController neopixelController;
    void powerOn(String url, WiFiClient& client);
    void powerOff(String url, WiFiClient& client);
    void colorHsv(String url, WiFiClient& client);
    void setBrightness(String url, WiFiClient& client);
    void setMode(String url, WiFiClient& client);
    void setFadeSpeed(String url, WiFiClient& client);
};

#endif

================
File: webserver/routehandler/routehandler.cpp
================
#include "routehandler.h"

RouteHandler::RouteHandler(HTTPMethod method, String route, std::function<void(String, WiFiClient&)> handler) {
    String methodString = method == GET ? "GET" : "POST";
    this->route = methodString + " " + route;
    this->handle = handler;
}

================
File: webserver/routehandler/routehandler.h
================
#ifndef ROUTE_HANDLER_H
#define ROUTE_HANDLER_H

#include <Arduino.h>
#include <ESP8266WiFi.h>
#include <functional>  // Include the header for std::function

enum HTTPMethod {
    GET,
    POST
};

class RouteHandler {
    public:
        RouteHandler(HTTPMethod method, String route, std::function<void(String, WiFiClient&)> handler);
        std::function<void(String, WiFiClient&)> handle;
        String route;
};

#endif

================
File: webserver/webserver.cpp
================
#include "webserver.h"

WebServer::WebServer(String _mdnsName): 
server(80), 
mdnsName(_mdnsName),
lastMDNSUpdate(millis())
{}

void WebServer::init() {
    Serial.print("Connecting to ");
    Serial.println(SSID);
    WiFi.begin(SSID, PASSWORD);
    while (WiFi.status() != WL_CONNECTED) {
        delay(500);
        Serial.print(".");
    }
    Serial.println("\nWiFi connected.");
    Serial.print("IP address: ");
    Serial.println(WiFi.localIP());

    if (!MDNS.begin(this->mdnsName)) {  // Start the mDNS responder
        Serial.println("Error setting up MDNS responder!");
    }
    Serial.println("mDNS responder started for " + this->mdnsName);

    // Add service to MDNS-SD
    MDNS.addService("http", "tcp", 80);

    server.begin();
}

void WebServer::tick() {
    // Update mDNS every MDNS_UPDATE_INTERVAL milliseconds
    if(millis() - lastMDNSUpdate > MDNS_UPDATE_INTERVAL) {
        lastMDNSUpdate = millis();

        // Call MDNS.update() to make sure queries are processed
        MDNS.update();
    }

    WiFiClient client = server.available(); // Check for incoming clients

    if (!client) {
        return; // Early exit if no client is connected
    }

    Serial.println("New Client.");
    while (client.connected()) {
        if (client.available()) {
            char c = client.read();
            //Serial.write(c);
            header += c;

            if (c == '\n' && currentLine.isEmpty()) {
                sendHttpResponse(client);
                break; // Exit if the end of the client HTTP request
            }
            handleIncomingChar(c);
        }
    }

    cleanupClient(client);
}

void WebServer::handleIncomingChar(char c) {
    if (c == '\n') {
        currentLine = ""; // Clear current line if new line
    } else if (c != '\r') {
        currentLine += c; // Append to current line if not carriage return
    }
}

void WebServer::sendHttpResponse(WiFiClient& client) {
    client.println("HTTP/1.1 200 OK");
    client.println("Content-type:application/json");
    client.println("Access-Control-Allow-Origin: *"); // Allows all domains
    client.println("Access-Control-Allow-Methods: GET, POST, PUT, DELETE, OPTIONS"); // Specifies allowed methods
    client.println("Access-Control-Allow-Headers: Content-Type, Authorization, X-Requested-With"); // Specifies allowed headers
    client.println("Connection: close");
    client.println();

    processApiRoutes(client);
    client.println(); // End the HTTP response with a blank line
}

void WebServer::processApiRoutes(WiFiClient& client) {
    for(int i = 0; i < 10; i++) {
        if(routes[i] != NULL) {
            if(header.indexOf(routes[i]->route) >= 0) {
                routes[i]->handle(header, client);
            }
        }
    }
}

void WebServer::cleanupClient(WiFiClient& client) {
    header = "";
    client.stop();
    Serial.println("Client disconnected.\n");
}

void WebServer::registerRoute(RouteHandler* routeHandler) {
    Serial.println("Registering route: " + routeHandler->route);

    // Find the first available route slot
    for (int i = 0; i < 10; i++) {
        if (routes[i] == NULL) {
            routes[i] = routeHandler;
            break;
        }
    }
}

================
File: webserver/webserver.h
================
#ifndef WEBSERVER_H
#define WEBSERVER_H

#include <Arduino.h>
#include "routehandler/routehandler.h"
#include <ESP8266WiFi.h>
#include <ESP8266mDNS.h>

#define SSID     "Fios-DMGk8"
#define PASSWORD "fit56jolly676gum"

#define MDNS_UPDATE_INTERVAL 1000 // Update mDNS every 1000ms

class WebServer {
public:
    WebServer(String);
    void init();
    void tick();
    void handleIncomingChar(char);
    void sendHttpResponse(WiFiClient&);
    void processApiRoutes(WiFiClient&);
    void cleanupClient(WiFiClient&);
    void registerRoute(RouteHandler*);
private:
    WiFiServer server;
    String mdnsName;
    String header;
    String currentLine;
    long lastMDNSUpdate;
    RouteHandler* routes[10]; // Max of 10 routes
};

#endif
